import {
  VBadge,
  VPicker,
  VPickerTitle,
  VSheet,
  makeCalendarProps,
  makeFilterProps,
  useCalendar,
  useFilter
} from "./chunk-QS3BWOAQ.js";
import "./chunk-B3J25GK7.js";
import "./chunk-4YBD2GZT.js";
import "./chunk-G6KDFCY5.js";
import "./chunk-B6ND2KW3.js";
import "./chunk-YOMYKF4H.js";
import "./chunk-2PSEIA2V.js";
import "./chunk-Z3FWCZQJ.js";
import {
  VChip,
  VList,
  VListGroup,
  VListItem,
  VListItemAction,
  VMenu,
  makeVListGroupProps,
  makeVListItemProps,
  makeVListProps,
  makeVMenuProps,
  useListItems
} from "./chunk-5YURTN3T.js";
import "./chunk-TQBVSGKW.js";
import "./chunk-O5V6C5IT.js";
import {
  VCheckboxBtn
} from "./chunk-GTQUJCHN.js";
import "./chunk-BQSUHESW.js";
import "./chunk-3EBIIFGM.js";
import "./chunk-I67THXFD.js";
import "./chunk-NESCDFUC.js";
import {
  useDate
} from "./chunk-ICT4FO5O.js";
import "./chunk-6TJCI762.js";
import "./chunk-YM3CAJSR.js";
import {
  VBtn,
  VProgressCircular,
  makeVBtnProps
} from "./chunk-22C2P2YY.js";
import "./chunk-KBPLETDG.js";
import "./chunk-EYWQMUD6.js";
import {
  VImg
} from "./chunk-ZPPPQT35.js";
import "./chunk-QRIRIHVX.js";
import "./chunk-ORTCFDM5.js";
import "./chunk-XS3GNKGP.js";
import "./chunk-ETAKTQC7.js";
import "./chunk-TARLPIDO.js";
import "./chunk-PGYNJARL.js";
import "./chunk-EBQO5NI2.js";
import {
  VIcon,
  makeSizeProps
} from "./chunk-KAPX7546.js";
import "./chunk-GIL6KQD5.js";
import {
  VDefaultsProvider,
  makeDimensionProps,
  useDimension
} from "./chunk-Z2AGKWKH.js";
import {
  useLink
} from "./chunk-P7BEHD5V.js";
import "./chunk-I56G2PY2.js";
import {
  MaybeTransition,
  makeTransitionProps
} from "./chunk-COEJR7YC.js";
import {
  useBackgroundColor,
  useTextColor
} from "./chunk-ORZXOTHK.js";
import {
  makeLayoutItemProps,
  useLayoutItem
} from "./chunk-VEJSGIXD.js";
import {
  useResizeObserver
} from "./chunk-NKAIPKTH.js";
import {
  IconValue
} from "./chunk-4FJATGX7.js";
import {
  makeThemeProps,
  provideTheme,
  useLocale,
  useProxiedModel,
  useToggleScope
} from "./chunk-PPIO5M5L.js";
import {
  chunkArray,
  convertToUnit,
  deepEqual,
  genericComponent,
  getPropertyFromItem,
  getUid,
  makeComponentProps,
  omit,
  propsFactory,
  provideDefaults,
  useRender
} from "./chunk-OA773M47.js";
import {
  Fragment,
  computed,
  createVNode,
  inject,
  mergeProps,
  nextTick,
  provide,
  ref,
  shallowRef,
  toRaw,
  toRef,
  vShow,
  watch,
  watchEffect,
  withDirectives
} from "./chunk-AZ23VQUG.js";
import "./chunk-Y2F7D3TJ.js";

// node_modules/vuetify/lib/labs/VCalendar/VCalendar.mjs
import "C:/Users/rakov/OneDrive/Рабочий стол/test/test/node_modules/vuetify/lib/labs/VCalendar/VCalendar.css";

// node_modules/vuetify/lib/labs/VCalendar/VCalendarDay.mjs
import "C:/Users/rakov/OneDrive/Рабочий стол/test/test/node_modules/vuetify/lib/labs/VCalendar/VCalendarDay.css";

// node_modules/vuetify/lib/labs/VCalendar/VCalendarInterval.mjs
import "C:/Users/rakov/OneDrive/Рабочий стол/test/test/node_modules/vuetify/lib/labs/VCalendar/VCalendarInterval.css";

// node_modules/vuetify/lib/labs/VCalendar/VCalendarIntervalEvent.mjs
import "C:/Users/rakov/OneDrive/Рабочий стол/test/test/node_modules/vuetify/lib/labs/VCalendar/VCalendarIntervalEvent.css";
var makeVCalendarIntervalEventProps = propsFactory({
  allDay: Boolean,
  interval: Object,
  intervalDivisions: {
    type: Number,
    required: true
  },
  intervalDuration: {
    type: Number,
    required: true
  },
  intervalHeight: {
    type: Number,
    required: true
  },
  event: Object
}, "VCalendarIntervalEvent");
var VCalendarIntervalEvent = genericComponent()({
  name: "VCalendarIntervalEvent",
  props: makeVCalendarIntervalEventProps(),
  setup(props) {
    const adapter = useDate();
    const calcHeight = () => {
      var _a, _b, _c, _d;
      if (!((_a = props.event) == null ? void 0 : _a.first) && !((_b = props.event) == null ? void 0 : _b.last) || adapter.isEqual((_c = props.event) == null ? void 0 : _c.start, (_d = props.interval) == null ? void 0 : _d.start)) {
        return {
          height: "100%",
          margin: convertToUnit(0)
        };
      } else {
        const {
          height,
          margin
        } = Array.from({
          length: props.intervalDivisions
        }, (x) => x * (props.intervalDuration / props.intervalDivisions)).reduce((total, div, index) => {
          var _a2, _b2;
          if (adapter.isBefore(adapter.addMinutes((_a2 = props.interval) == null ? void 0 : _a2.start, div), (_b2 = props.event) == null ? void 0 : _b2.start)) {
            return {
              height: convertToUnit(props.intervalHeight / props.intervalDivisions * index),
              margin: convertToUnit(props.intervalHeight / props.intervalDivisions * index)
            };
          }
          return {
            height: total.height,
            margin: total.margin
          };
        }, {
          height: "",
          margin: ""
        });
        return {
          height,
          margin
        };
      }
    };
    useRender(() => {
      var _a, _b, _c, _d, _e;
      return createVNode(VSheet, {
        "height": calcHeight().height,
        "density": "comfortable",
        "style": `margin-top: ${calcHeight().margin}`,
        "class": "v-calendar-internal-event",
        "color": ((_a = props.event) == null ? void 0 : _a.color) ?? void 0,
        "rounded": ((_b = props.event) == null ? void 0 : _b.first) && ((_c = props.event) == null ? void 0 : _c.last) ? true : ((_d = props.event) == null ? void 0 : _d.first) ? "t" : ((_e = props.event) == null ? void 0 : _e.last) ? "b" : false
      }, {
        default: () => {
          var _a2, _b2;
          return [((_a2 = props.event) == null ? void 0 : _a2.first) ? (_b2 = props.event) == null ? void 0 : _b2.title : ""];
        }
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendarInterval.mjs
var makeVCalendarIntervalProps = propsFactory({
  day: {
    type: Object,
    default: () => ({})
  },
  dayIndex: Number,
  events: Array,
  intervalDivisions: {
    type: Number,
    default: 2
  },
  intervalDuration: {
    type: Number,
    default: 60
  },
  intervalHeight: {
    type: Number,
    default: 48
  },
  intervalFormat: {
    type: [String, Function],
    default: "fullTime12h"
  },
  intervalStart: {
    type: Number,
    default: 0
  }
}, "VCalendarInterval");
var VCalendarInterval = genericComponent()({
  name: "VCalendarInterval",
  props: {
    index: {
      type: Number,
      required: true
    },
    ...makeVCalendarIntervalProps()
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const adapter = useDate();
    const interval = computed(() => {
      const start = adapter.addMinutes(adapter.startOfDay(props.day.date), props.intervalDuration * (props.index + props.intervalStart));
      const end = adapter.addMinutes(adapter.startOfDay(props.day.date), props.intervalDuration * (props.index + props.intervalStart + 1) - 1);
      return {
        ...props.day,
        label: adapter.format(start, "fullTime24h"),
        start,
        end,
        events: props.events ? props.events.filter((e) => !e.allDay && (adapter.isEqual(start, e.start) || adapter.isWithinRange(e.start, [start, end]) || adapter.isWithinRange(start, [e.start, e.end]) || adapter.isEqual(end, e.end))).map((e) => {
          return {
            ...e,
            first: adapter.isEqual(start, e.start) || adapter.isWithinRange(e.start, [start, end]),
            last: adapter.isEqual(end, e.end) || adapter.isWithinRange(e.end, [start, end])
          };
        }) : []
      };
    });
    useRender(() => {
      var _a, _b;
      return props.dayIndex === 0 ? createVNode("div", {
        "class": "v-calendar-day__row-with-label",
        "style": `height: ${convertToUnit(props.intervalHeight)}`
      }, [createVNode("div", {
        "class": "v-calendar-day__row-label"
      }, [createVNode("slot", {
        "name": "intervalFormat",
        "interval": interval.value
      }, [props.index ? props.intervalFormat ? typeof props.intervalFormat === "string" ? adapter.format(interval.value.start, "hours12h") : props.intervalFormat(interval.value) : interval.value.label : ""])]), createVNode("div", {
        "class": "v-calendar-day__row-hairline"
      }, null), createVNode("div", {
        "class": ["v-calendar-day__row-content", interval.value.events.some((e) => !e.last) ? "v-calendar-day__row-content-through" : ""]
      }, [createVNode("slot", {
        "name": "intervalBody",
        "interval": interval.value
      }, [(_a = interval.value.events) == null ? void 0 : _a.map((event) => createVNode(VCalendarIntervalEvent, {
        "event": event,
        "interval": interval.value,
        "intervalDivisions": props.intervalDivisions,
        "intervalDuration": props.intervalDuration,
        "intervalHeight": props.intervalHeight
      }, null))])])]) : createVNode("div", {
        "class": "v-calendar-day__row-without-label",
        "style": `height: ${convertToUnit(props.intervalHeight)}`
      }, [createVNode("div", {
        "class": ["v-calendar-day__row-content", interval.value.events.some((e) => !e.last) ? "v-calendar-day__row-content-through" : ""]
      }, [createVNode("slot", {
        "name": "intervalBody",
        "interval": interval.value
      }, [(_b = interval.value.events) == null ? void 0 : _b.filter((event) => !event.allDay).map((event) => createVNode(VCalendarIntervalEvent, {
        "event": event,
        "interval": interval.value,
        "intervalDivisions": props.intervalDivisions,
        "intervalDuration": props.intervalDuration,
        "intervalHeight": props.intervalHeight
      }, null))])])]);
    });
    return {
      interval
    };
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendarDay.mjs
var makeVCalendarDayProps = propsFactory({
  hideDayHeader: Boolean,
  intervals: {
    type: Number,
    default: 24
  },
  ...makeVCalendarIntervalProps()
}, "VCalendarDay");
var VCalendarDay = genericComponent()({
  name: "VCalendarDay",
  props: makeVCalendarDayProps(),
  setup(props) {
    const adapter = useDate();
    const intervals = computed(() => [...Array.from({
      length: props.intervals
    }, (v, i) => i).filter((int2, index) => props.intervalDuration * (index + props.intervalStart) < 1440)]);
    useRender(() => {
      const calendarIntervalProps = VCalendarInterval.filterProps(props);
      return createVNode("div", {
        "class": "v-calendar-day__container"
      }, [!props.hideDayHeader && createVNode("div", {
        "key": "calender-week-name",
        "class": "v-calendar-weekly__head-weekday"
      }, [adapter.format(props.day.date, "weekdayShort"), createVNode("div", null, [createVNode(VBtn, {
        "icon": true,
        "text": adapter.format(props.day.date, "dayOfMonth"),
        "variant": "text"
      }, null)])]), intervals.value.map((_, index) => createVNode(VCalendarInterval, mergeProps({
        "index": index
      }, calendarIntervalProps), null))]);
    });
    return {
      intervals
    };
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendarHeader.mjs
import "C:/Users/rakov/OneDrive/Рабочий стол/test/test/node_modules/vuetify/lib/labs/VCalendar/VCalendarHeader.css";
var makeVCalendarHeaderProps = propsFactory({
  nextIcon: {
    type: String,
    default: "$next"
  },
  prevIcon: {
    type: String,
    default: "$prev"
  },
  title: String,
  text: {
    type: String,
    default: "$vuetify.calendar.today"
  },
  viewMode: {
    type: String,
    default: "month"
  }
}, "VCalendarHeader");
var VCalendarHeader = genericComponent()({
  name: "VCalendarHeader",
  props: makeVCalendarHeaderProps(),
  emits: {
    "click:next": () => true,
    "click:prev": () => true,
    "click:toToday": () => true
  },
  setup(props, _ref) {
    let {
      emit
    } = _ref;
    const {
      t
    } = useLocale();
    function prev() {
      emit("click:prev");
    }
    function next() {
      emit("click:next");
    }
    function toToday() {
      emit("click:toToday");
    }
    useRender(() => createVNode("div", {
      "class": "v-calendar-header"
    }, [props.text && createVNode(VBtn, {
      "key": "today",
      "class": "v-calendar-header__today",
      "text": t(props.text),
      "variant": "outlined",
      "onClick": toToday
    }, null), createVNode(VBtn, {
      "density": "comfortable",
      "icon": props.prevIcon,
      "variant": "text",
      "onClick": prev
    }, null), createVNode(VBtn, {
      "density": "comfortable",
      "icon": props.nextIcon,
      "variant": "text",
      "onClick": next
    }, null), createVNode("div", {
      "class": "v-calendar-header__title"
    }, [props.title])]));
    return {};
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendarMonthDay.mjs
import "C:/Users/rakov/OneDrive/Рабочий стол/test/test/node_modules/vuetify/lib/labs/VCalendar/VCalendarMonthDay.css";

// node_modules/vuetify/lib/labs/VCalendar/VCalendarEvent.mjs
var makeVCalendarEventProps = propsFactory({
  allDay: Boolean,
  day: Object,
  event: Object
}, "VCalendarEvent");
var VCalendarEvent = genericComponent()({
  name: "VCalendarEvent",
  props: makeVCalendarEventProps(),
  setup(props) {
    useRender(() => createVNode(VChip, {
      "color": props.allDay ? "primary" : void 0,
      "density": "comfortable",
      "label": props.allDay,
      "width": "100%"
    }, {
      default: () => {
        var _a, _b;
        return [createVNode(VBadge, {
          "inline": true,
          "dot": true,
          "color": (_a = props.event) == null ? void 0 : _a.color
        }, null), (_b = props.event) == null ? void 0 : _b.title];
      }
    }));
    return {};
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendarMonthDay.mjs
var makeVCalendarMonthDayProps = propsFactory({
  active: Boolean,
  color: String,
  day: Object,
  disabled: Boolean,
  events: Array,
  title: [Number, String]
}, "VCalendarMonthDay");
var VCalendarMonthDay = genericComponent()({
  name: "VCalendarMonthDay",
  props: makeVCalendarMonthDayProps(),
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    useRender(() => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i;
      const hasTitle = !!(props.title || ((_a = slots.title) == null ? void 0 : _a.call(slots, {
        title: props.title
      })));
      return createVNode("div", {
        "class": ["v-calendar-month__day"]
      }, [!((_b = props.day) == null ? void 0 : _b.isHidden) && hasTitle && createVNode("div", {
        "key": "title",
        "class": "v-calendar-weekly__day-label"
      }, [((_c = slots.title) == null ? void 0 : _c.call(slots, {
        title: props.title
      })) ?? createVNode(VBtn, {
        "class": ((_d = props.day) == null ? void 0 : _d.isToday) ? "v-calendar-weekly__day-label__today" : void 0,
        "color": props.color,
        "disabled": props.disabled,
        "icon": true,
        "size": "x-small",
        "variant": ((_e = props.day) == null ? void 0 : _e.isToday) ? void 0 : "flat"
      }, {
        default: () => [props.title]
      })]), createVNode("div", {
        "key": "content",
        "class": "v-calendar-weekly__day-content"
      }, [((_f = slots.content) == null ? void 0 : _f.call(slots)) ?? createVNode("div", null, [createVNode("div", {
        "class": "v-calendar-weekly__day-alldayevents-container"
      }, [(_g = props.events) == null ? void 0 : _g.filter((event) => event.allDay).map((event) => createVNode(VCalendarEvent, {
        "day": props.day,
        "event": event,
        "allDay": true
      }, null))]), createVNode("div", {
        "class": "v-calendar-weekly__day-events-container"
      }, [(_h = props.events) == null ? void 0 : _h.filter((event) => !event.allDay).map((event) => createVNode(VCalendarEvent, {
        "day": props.day,
        "event": event
      }, null))])])]), (_i = slots.default) == null ? void 0 : _i.call(slots)]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VCalendar/VCalendar.mjs
var makeVCalendarProps = propsFactory({
  hideHeader: Boolean,
  hideWeekNumber: Boolean,
  ...makeCalendarProps(),
  ...makeVCalendarDayProps(),
  ...makeVCalendarHeaderProps()
}, "VCalender");
var VCalendar = genericComponent()({
  name: "VCalendar",
  props: makeVCalendarProps(),
  emits: {
    next: null,
    prev: null,
    "update:modelValue": null
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const adapter = useDate();
    const {
      daysInMonth,
      daysInWeek,
      genDays,
      model,
      weekNumbers
    } = useCalendar(props);
    const dayNames = adapter.getWeekdays();
    function onClickNext() {
      if (props.viewMode === "month") {
        model.value = [adapter.addMonths(model.value[0], 1)];
      }
      if (props.viewMode === "week") {
        model.value = [adapter.addDays(model.value[0], 7)];
      }
      if (props.viewMode === "day") {
        model.value = [adapter.addDays(model.value[0], 1)];
      }
    }
    function onClickPrev() {
      if (props.viewMode === "month") {
        model.value = [adapter.addMonths(model.value[0], -1)];
      }
      if (props.viewMode === "week") {
        model.value = [adapter.addDays(model.value[0], -7)];
      }
      if (props.viewMode === "day") {
        model.value = [adapter.addDays(model.value[0], -1)];
      }
    }
    function onClickToday() {
      model.value = [/* @__PURE__ */ new Date()];
    }
    const title = computed(() => {
      return adapter.format(model.value[0], "monthAndYear");
    });
    useRender(() => {
      var _a;
      const calendarDayProps = VCalendarDay.filterProps(props);
      const calendarHeaderProps = VCalendarHeader.filterProps(props);
      return createVNode("div", {
        "class": ["v-calendar", {
          "v-calendar-monthly": props.viewMode === "month",
          "v-calendar-weekly": props.viewMode === "week",
          "v-calendar-day": props.viewMode === "day"
        }]
      }, [createVNode("div", null, [!props.hideHeader && (!slots.header ? createVNode(VCalendarHeader, mergeProps({
        "key": "calendar-header"
      }, calendarHeaderProps, {
        "title": title.value,
        "onClick:next": onClickNext,
        "onClick:prev": onClickPrev,
        "onClick:toToday": onClickToday
      }), null) : slots.header({
        title: title.value
      }))]), createVNode("div", {
        "class": ["v-calendar__container", `days__${props.weekdays.length}`]
      }, [props.viewMode === "month" && !props.hideDayHeader && createVNode("div", {
        "class": ["v-calendar-weekly__head", `days__${props.weekdays.length}`, ...!props.hideWeekNumber ? ["v-calendar-weekly__head-weeknumbers"] : []],
        "key": "calenderWeeklyHead"
      }, [!props.hideWeekNumber ? createVNode("div", {
        "key": "weekNumber0",
        "class": "v-calendar-weekly__head-weeknumber"
      }, null) : "", props.weekdays.map((weekday) => createVNode("div", {
        "class": `v-calendar-weekly__head-weekday${!props.hideWeekNumber ? "-with-weeknumber" : ""}`
      }, [dayNames[weekday]]))]), props.viewMode === "month" && createVNode("div", {
        "key": "VCalendarMonth",
        "class": ["v-calendar-month__days", `days${!props.hideWeekNumber ? "-with-weeknumbers" : ""}__${props.weekdays.length}`, ...!props.hideWeekNumber ? ["v-calendar-month__weeknumbers"] : []]
      }, [chunkArray(daysInMonth.value, props.weekdays.length).map((week, wi) => [!props.hideWeekNumber ? createVNode("div", {
        "class": "v-calendar-month__weeknumber"
      }, [weekNumbers.value[wi]]) : "", week.map((day) => {
        var _a2;
        return createVNode(VCalendarMonthDay, {
          "color": adapter.isSameDay(/* @__PURE__ */ new Date(), day.date) ? "primary" : void 0,
          "day": day,
          "title": day ? adapter.format(day.date, "dayOfMonth") : "NaN",
          "events": (_a2 = props.events) == null ? void 0 : _a2.filter((e) => adapter.isSameDay(day.date, e.start) || adapter.isSameDay(day.date, e.end))
        }, null);
      })])]), props.viewMode === "week" && daysInWeek.value.map((day, i) => {
        var _a2;
        return createVNode(VCalendarDay, mergeProps(calendarDayProps, {
          "day": day,
          "dayIndex": i,
          "events": (_a2 = props.events) == null ? void 0 : _a2.filter((e) => adapter.isSameDay(e.start, day.date) || adapter.isSameDay(e.end, day.date))
        }), null);
      }), props.viewMode === "day" && createVNode(VCalendarDay, mergeProps(calendarDayProps, {
        "day": genDays([model.value[0]], adapter.date())[0],
        "events": (_a = props.events) == null ? void 0 : _a.filter((e) => adapter.isSameDay(e.start, genDays([model.value[0]], adapter.date())[0].date) || adapter.isSameDay(e.end, genDays([model.value[0]], adapter.date())[0].date))
      }), null)])]);
    });
    return {
      daysInMonth,
      daysInWeek,
      genDays
    };
  }
});

// node_modules/vuetify/lib/labs/VConfirmEdit/VConfirmEdit.mjs
var makeVConfirmEditProps = propsFactory({
  modelValue: null,
  color: String,
  cancelText: {
    type: String,
    default: "$vuetify.confirmEdit.cancel"
  },
  okText: {
    type: String,
    default: "$vuetify.confirmEdit.ok"
  }
}, "VConfirmEdit");
var VConfirmEdit = genericComponent()({
  name: "VConfirmEdit",
  props: makeVConfirmEditProps(),
  emits: {
    cancel: () => true,
    save: (value) => true,
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const internalModel = ref();
    watchEffect(() => {
      internalModel.value = structuredClone(toRaw(model.value));
    });
    const {
      t
    } = useLocale();
    const isPristine = computed(() => {
      return deepEqual(model.value, internalModel.value);
    });
    function save() {
      model.value = internalModel.value;
      emit("save", internalModel.value);
    }
    function cancel() {
      internalModel.value = structuredClone(toRaw(model.value));
      emit("cancel");
    }
    let actionsUsed = false;
    useRender(() => {
      var _a;
      const actions = createVNode(Fragment, null, [createVNode(VBtn, {
        "disabled": isPristine.value,
        "variant": "text",
        "color": props.color,
        "onClick": cancel,
        "text": t(props.cancelText)
      }, null), createVNode(VBtn, {
        "disabled": isPristine.value,
        "variant": "text",
        "color": props.color,
        "onClick": save,
        "text": t(props.okText)
      }, null)]);
      return createVNode(Fragment, null, [(_a = slots.default) == null ? void 0 : _a.call(slots, {
        model: internalModel,
        get actions() {
          actionsUsed = true;
          return actions;
        }
      }), !actionsUsed && actions]);
    });
  }
});

// node_modules/vuetify/lib/labs/VEmptyState/VEmptyState.mjs
import "C:/Users/rakov/OneDrive/Рабочий стол/test/test/node_modules/vuetify/lib/labs/VEmptyState/VEmptyState.css";
var makeVEmptyStateProps = propsFactory({
  actionText: String,
  bgColor: String,
  color: String,
  icon: IconValue,
  image: String,
  justify: {
    type: String,
    default: "center"
  },
  headline: String,
  title: String,
  text: String,
  textWidth: {
    type: [Number, String],
    default: 500
  },
  href: String,
  to: String,
  ...makeComponentProps(),
  ...makeDimensionProps(),
  ...makeSizeProps({
    size: void 0
  }),
  ...makeThemeProps()
}, "VEmptyState");
var VEmptyState = genericComponent()({
  name: "VEmptyState",
  props: makeVEmptyStateProps(),
  emits: {
    "click:action": (e) => true
  },
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "bgColor"));
    const {
      dimensionStyles
    } = useDimension(props);
    function onClickAction(e) {
      emit("click:action", e);
    }
    useRender(() => {
      var _a, _b, _c;
      const hasActions = !!(slots.actions || props.actionText);
      const hasHeadline = !!(slots.headline || props.headline);
      const hasTitle = !!(slots.title || props.title);
      const hasText = !!(slots.text || props.text);
      const hasMedia = !!(slots.media || props.image || props.icon);
      const size = props.size || (props.image ? 200 : 96);
      return createVNode("div", {
        "class": ["v-empty-state", {
          [`v-empty-state--${props.justify}`]: true
        }, themeClasses.value, backgroundColorClasses.value, props.class],
        "style": [backgroundColorStyles.value, dimensionStyles.value, props.style]
      }, [hasMedia && createVNode("div", {
        "key": "media",
        "class": "v-empty-state__media"
      }, [!slots.media ? createVNode(Fragment, null, [props.image ? createVNode(VImg, {
        "key": "image",
        "src": props.image,
        "height": size
      }, null) : props.icon ? createVNode(VIcon, {
        "key": "icon",
        "size": size,
        "icon": props.icon
      }, null) : void 0]) : createVNode(VDefaultsProvider, {
        "key": "media-defaults",
        "defaults": {
          VImg: {
            src: props.image,
            height: size
          },
          VIcon: {
            size,
            icon: props.icon
          }
        }
      }, {
        default: () => [slots.media()]
      })]), hasHeadline && createVNode("div", {
        "key": "headline",
        "class": "v-empty-state__headline"
      }, [((_a = slots.headline) == null ? void 0 : _a.call(slots)) ?? props.headline]), hasTitle && createVNode("div", {
        "key": "title",
        "class": "v-empty-state__title"
      }, [((_b = slots.title) == null ? void 0 : _b.call(slots)) ?? props.title]), hasText && createVNode("div", {
        "key": "text",
        "class": "v-empty-state__text",
        "style": {
          maxWidth: convertToUnit(props.textWidth)
        }
      }, [((_c = slots.text) == null ? void 0 : _c.call(slots)) ?? props.text]), slots.default && createVNode("div", {
        "key": "content",
        "class": "v-empty-state__content"
      }, [slots.default()]), hasActions && createVNode("div", {
        "key": "actions",
        "class": "v-empty-state__actions"
      }, [createVNode(VDefaultsProvider, {
        "defaults": {
          VBtn: {
            class: "v-empty-state__action-btn",
            color: props.color,
            text: props.actionText
          }
        }
      }, {
        default: () => {
          var _a2;
          return [((_a2 = slots.actions) == null ? void 0 : _a2.call(slots, {
            props: {
              onClick: onClickAction
            }
          })) ?? createVNode(VBtn, {
            "onClick": onClickAction
          }, null)];
        }
      })])]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VFab/VFab.mjs
import "C:/Users/rakov/OneDrive/Рабочий стол/test/test/node_modules/vuetify/lib/labs/VFab/VFab.css";
var makeVFabProps = propsFactory({
  app: Boolean,
  appear: Boolean,
  extended: Boolean,
  location: {
    type: String,
    default: "bottom end"
  },
  offset: Boolean,
  modelValue: {
    type: Boolean,
    default: true
  },
  ...omit(makeVBtnProps({
    active: true
  }), ["location"]),
  ...makeLayoutItemProps(),
  ...makeTransitionProps({
    transition: "fab-transition"
  })
}, "VFab");
var VFab = genericComponent()({
  name: "VFab",
  props: makeVFabProps(),
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const height = shallowRef(56);
    const layoutItemStyles = ref();
    const {
      resizeRef
    } = useResizeObserver((entries) => {
      if (!entries.length)
        return;
      height.value = entries[0].target.clientHeight;
    });
    const hasPosition = computed(() => props.app || props.absolute);
    const position = computed(() => {
      if (!hasPosition.value)
        return false;
      return props.location.split(" ").shift();
    });
    const orientation = computed(() => {
      if (!hasPosition.value)
        return false;
      return props.location.split(" ")[1] ?? "end";
    });
    useToggleScope(() => props.app, () => {
      const layout = useLayoutItem({
        id: props.name,
        order: computed(() => parseInt(props.order, 10)),
        position,
        layoutSize: height,
        elementSize: computed(() => height.value + 32),
        active: computed(() => props.app && model.value),
        absolute: toRef(props, "absolute")
      });
      watchEffect(() => {
        layoutItemStyles.value = layout.layoutItemStyles.value;
      });
    });
    const vFabRef = ref();
    useRender(() => {
      const btnProps = VBtn.filterProps(props);
      return createVNode("div", {
        "ref": vFabRef,
        "class": ["v-fab", {
          "v-fab--absolute": props.absolute,
          "v-fab--app": !!props.app,
          "v-fab--extended": props.extended,
          "v-fab--offset": props.offset,
          [`v-fab--${position.value}`]: hasPosition.value,
          [`v-fab--${orientation.value}`]: hasPosition.value
        }, props.class],
        "style": [props.app ? {
          ...layoutItemStyles.value
        } : {
          height: "inherit",
          width: void 0
        }, props.style]
      }, [createVNode("div", {
        "class": "v-fab__container"
      }, [createVNode(MaybeTransition, {
        "appear": props.appear,
        "transition": props.transition
      }, {
        default: () => [withDirectives(createVNode(VBtn, mergeProps({
          "ref": resizeRef
        }, btnProps, {
          "active": void 0,
          "location": void 0
        }), slots), [[vShow, props.active]])]
      })])]);
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VSparkline/util/line.mjs
var makeLineProps = propsFactory({
  autoDraw: Boolean,
  autoDrawDuration: [Number, String],
  autoDrawEasing: {
    type: String,
    default: "ease"
  },
  color: String,
  gradient: {
    type: Array,
    default: () => []
  },
  gradientDirection: {
    type: String,
    validator: (val) => ["top", "bottom", "left", "right"].includes(val),
    default: "top"
  },
  height: {
    type: [String, Number],
    default: 75
  },
  labels: {
    type: Array,
    default: () => []
  },
  labelSize: {
    type: [Number, String],
    default: 7
  },
  lineWidth: {
    type: [String, Number],
    default: 4
  },
  id: String,
  itemValue: {
    type: String,
    default: "value"
  },
  modelValue: {
    type: Array,
    default: () => []
  },
  min: [String, Number],
  max: [String, Number],
  padding: {
    type: [String, Number],
    default: 8
  },
  showLabels: Boolean,
  smooth: Boolean,
  width: {
    type: [Number, String],
    default: 300
  }
}, "Line");

// node_modules/vuetify/lib/labs/VSparkline/VBarline.mjs
var makeVBarlineProps = propsFactory({
  autoLineWidth: Boolean,
  ...makeLineProps()
}, "VBarline");
var VBarline = genericComponent()({
  name: "VBarline",
  props: makeVBarlineProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const uid = getUid();
    const id = computed(() => props.id || `barline-${uid}`);
    const autoDrawDuration = computed(() => Number(props.autoDrawDuration) || 500);
    const hasLabels = computed(() => {
      return Boolean(props.showLabels || props.labels.length > 0 || !!(slots == null ? void 0 : slots.label));
    });
    const lineWidth = computed(() => parseFloat(props.lineWidth) || 4);
    const totalWidth = computed(() => Math.max(props.modelValue.length * lineWidth.value, Number(props.width)));
    const boundary = computed(() => {
      return {
        minX: 0,
        maxX: totalWidth.value,
        minY: 0,
        maxY: parseInt(props.height, 10)
      };
    });
    const items = computed(() => props.modelValue.map((item) => getPropertyFromItem(item, props.itemValue, item)));
    function genBars(values, boundary2) {
      const {
        minX,
        maxX,
        minY,
        maxY
      } = boundary2;
      const totalValues = values.length;
      let maxValue = props.max != null ? Number(props.max) : Math.max(...values);
      let minValue = props.min != null ? Number(props.min) : Math.min(...values);
      if (minValue > 0 && props.min == null)
        minValue = 0;
      if (maxValue < 0 && props.max == null)
        maxValue = 0;
      const gridX = maxX / totalValues;
      const gridY = (maxY - minY) / (maxValue - minValue || 1);
      const horizonY = maxY - Math.abs(minValue * gridY);
      return values.map((value, index) => {
        const height = Math.abs(gridY * value);
        return {
          x: minX + index * gridX,
          y: horizonY - height + +(value < 0) * height,
          height,
          value
        };
      });
    }
    const parsedLabels = computed(() => {
      const labels = [];
      const points = genBars(items.value, boundary.value);
      const len = points.length;
      for (let i = 0; labels.length < len; i++) {
        const item = points[i];
        let value = props.labels[i];
        if (!value) {
          value = typeof item === "object" ? item.value : item;
        }
        labels.push({
          x: item.x,
          value: String(value)
        });
      }
      return labels;
    });
    const bars = computed(() => genBars(items.value, boundary.value));
    const offsetX = computed(() => (Math.abs(bars.value[0].x - bars.value[1].x) - lineWidth.value) / 2);
    useRender(() => {
      const gradientData = !props.gradient.slice().length ? [""] : props.gradient.slice().reverse();
      return createVNode("svg", {
        "display": "block"
      }, [createVNode("defs", null, [createVNode("linearGradient", {
        "id": id.value,
        "gradientUnits": "userSpaceOnUse",
        "x1": props.gradientDirection === "left" ? "100%" : "0",
        "y1": props.gradientDirection === "top" ? "100%" : "0",
        "x2": props.gradientDirection === "right" ? "100%" : "0",
        "y2": props.gradientDirection === "bottom" ? "100%" : "0"
      }, [gradientData.map((color, index) => createVNode("stop", {
        "offset": index / Math.max(gradientData.length - 1, 1),
        "stop-color": color || "currentColor"
      }, null))])]), createVNode("clipPath", {
        "id": `${id.value}-clip`
      }, [bars.value.map((item) => createVNode("rect", {
        "x": item.x + offsetX.value,
        "y": item.y,
        "width": lineWidth.value,
        "height": item.height,
        "rx": typeof props.smooth === "number" ? props.smooth : props.smooth ? 2 : 0,
        "ry": typeof props.smooth === "number" ? props.smooth : props.smooth ? 2 : 0
      }, [props.autoDraw && createVNode(Fragment, null, [createVNode("animate", {
        "attributeName": "y",
        "from": item.y + item.height,
        "to": item.y,
        "dur": `${autoDrawDuration.value}ms`,
        "fill": "freeze"
      }, null), createVNode("animate", {
        "attributeName": "height",
        "from": "0",
        "to": item.height,
        "dur": `${autoDrawDuration.value}ms`,
        "fill": "freeze"
      }, null)])]))]), hasLabels.value && createVNode("g", {
        "key": "labels",
        "style": {
          textAnchor: "middle",
          dominantBaseline: "mathematical",
          fill: "currentColor"
        }
      }, [parsedLabels.value.map((item, i) => {
        var _a;
        return createVNode("text", {
          "x": item.x + offsetX.value + lineWidth.value / 2,
          "y": parseInt(props.height, 10) - 2 + (parseInt(props.labelSize, 10) || 7 * 0.75),
          "font-size": Number(props.labelSize) || 7
        }, [((_a = slots.label) == null ? void 0 : _a.call(slots, {
          index: i,
          value: item.value
        })) ?? item.value]);
      })]), createVNode("g", {
        "clip-path": `url(#${id.value}-clip)`,
        "fill": `url(#${id.value})`
      }, [createVNode("rect", {
        "x": 0,
        "y": 0,
        "width": Math.max(props.modelValue.length * lineWidth.value, Number(props.width)),
        "height": props.height
      }, null)])]);
    });
  }
});

// node_modules/vuetify/lib/labs/VSparkline/util/path.mjs
function genPath(points, radius) {
  let fill = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  let height = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 75;
  if (points.length === 0)
    return "";
  const start = points.shift();
  const end = points[points.length - 1];
  return (fill ? `M${start.x} ${height - start.x + 2} L${start.x} ${start.y}` : `M${start.x} ${start.y}`) + points.map((point, index) => {
    const next = points[index + 1];
    const prev = points[index - 1] || start;
    const isCollinear = next && checkCollinear(next, point, prev);
    if (!next || isCollinear) {
      return `L${point.x} ${point.y}`;
    }
    const threshold = Math.min(getDistance(prev, point), getDistance(next, point));
    const isTooCloseForRadius = threshold / 2 < radius;
    const radiusForPoint = isTooCloseForRadius ? threshold / 2 : radius;
    const before = moveTo(prev, point, radiusForPoint);
    const after = moveTo(next, point, radiusForPoint);
    return `L${before.x} ${before.y}S${point.x} ${point.y} ${after.x} ${after.y}`;
  }).join("") + (fill ? `L${end.x} ${height - start.x + 2} Z` : "");
}
function int(value) {
  return parseInt(value, 10);
}
function checkCollinear(p0, p1, p2) {
  return int(p0.x + p2.x) === int(2 * p1.x) && int(p0.y + p2.y) === int(2 * p1.y);
}
function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}
function moveTo(to, from, radius) {
  const vector = {
    x: to.x - from.x,
    y: to.y - from.y
  };
  const length = Math.sqrt(vector.x * vector.x + vector.y * vector.y);
  const unitVector = {
    x: vector.x / length,
    y: vector.y / length
  };
  return {
    x: from.x + unitVector.x * radius,
    y: from.y + unitVector.y * radius
  };
}

// node_modules/vuetify/lib/labs/VSparkline/VTrendline.mjs
var makeVTrendlineProps = propsFactory({
  fill: Boolean,
  ...makeLineProps()
}, "VTrendline");
var VTrendline = genericComponent()({
  name: "VTrendline",
  props: makeVTrendlineProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const uid = getUid();
    const id = computed(() => props.id || `trendline-${uid}`);
    const autoDrawDuration = computed(() => Number(props.autoDrawDuration) || (props.fill ? 500 : 2e3));
    const lastLength = ref(0);
    const path = ref(null);
    function genPoints(values, boundary2) {
      const {
        minX,
        maxX,
        minY,
        maxY
      } = boundary2;
      const totalValues = values.length;
      const maxValue = props.max != null ? Number(props.max) : Math.max(...values);
      const minValue = props.min != null ? Number(props.min) : Math.min(...values);
      const gridX = (maxX - minX) / (totalValues - 1);
      const gridY = (maxY - minY) / (maxValue - minValue || 1);
      return values.map((value, index) => {
        return {
          x: minX + index * gridX,
          y: maxY - (value - minValue) * gridY,
          value
        };
      });
    }
    const hasLabels = computed(() => {
      return Boolean(props.showLabels || props.labels.length > 0 || !!(slots == null ? void 0 : slots.label));
    });
    const lineWidth = computed(() => {
      return parseFloat(props.lineWidth) || 4;
    });
    const totalWidth = computed(() => Number(props.width));
    const boundary = computed(() => {
      const padding = Number(props.padding);
      return {
        minX: padding,
        maxX: totalWidth.value - padding,
        minY: padding,
        maxY: parseInt(props.height, 10) - padding
      };
    });
    const items = computed(() => props.modelValue.map((item) => getPropertyFromItem(item, props.itemValue, item)));
    const parsedLabels = computed(() => {
      const labels = [];
      const points = genPoints(items.value, boundary.value);
      const len = points.length;
      for (let i = 0; labels.length < len; i++) {
        const item = points[i];
        let value = props.labels[i];
        if (!value) {
          value = typeof item === "object" ? item.value : item;
        }
        labels.push({
          x: item.x,
          value: String(value)
        });
      }
      return labels;
    });
    watch(() => props.modelValue, async () => {
      await nextTick();
      if (!props.autoDraw || !path.value)
        return;
      const pathRef = path.value;
      const length = pathRef.getTotalLength();
      if (!props.fill) {
        pathRef.style.strokeDasharray = `${length}`;
        pathRef.style.strokeDashoffset = `${length}`;
        pathRef.getBoundingClientRect();
        pathRef.style.transition = `stroke-dashoffset ${autoDrawDuration.value}ms ${props.autoDrawEasing}`;
        pathRef.style.strokeDashoffset = "0";
      } else {
        pathRef.style.transformOrigin = "bottom center";
        pathRef.style.transition = "none";
        pathRef.style.transform = `scaleY(0)`;
        pathRef.getBoundingClientRect();
        pathRef.style.transition = `transform ${autoDrawDuration.value}ms ${props.autoDrawEasing}`;
        pathRef.style.transform = `scaleY(1)`;
      }
      lastLength.value = length;
    }, {
      immediate: true
    });
    function genPath2(fill) {
      return genPath(genPoints(items.value, boundary.value), props.smooth ? 8 : Number(props.smooth), fill, parseInt(props.height, 10));
    }
    useRender(() => {
      var _a;
      const gradientData = !props.gradient.slice().length ? [""] : props.gradient.slice().reverse();
      return createVNode("svg", {
        "display": "block",
        "stroke-width": parseFloat(props.lineWidth) ?? 4
      }, [createVNode("defs", null, [createVNode("linearGradient", {
        "id": id.value,
        "gradientUnits": "userSpaceOnUse",
        "x1": props.gradientDirection === "left" ? "100%" : "0",
        "y1": props.gradientDirection === "top" ? "100%" : "0",
        "x2": props.gradientDirection === "right" ? "100%" : "0",
        "y2": props.gradientDirection === "bottom" ? "100%" : "0"
      }, [gradientData.map((color, index) => createVNode("stop", {
        "offset": index / Math.max(gradientData.length - 1, 1),
        "stop-color": color || "currentColor"
      }, null))])]), hasLabels.value && createVNode("g", {
        "key": "labels",
        "style": {
          textAnchor: "middle",
          dominantBaseline: "mathematical",
          fill: "currentColor"
        }
      }, [parsedLabels.value.map((item, i) => {
        var _a2;
        return createVNode("text", {
          "x": item.x + lineWidth.value / 2 + lineWidth.value / 2,
          "y": parseInt(props.height, 10) - 4 + (parseInt(props.labelSize, 10) || 7 * 0.75),
          "font-size": Number(props.labelSize) || 7
        }, [((_a2 = slots.label) == null ? void 0 : _a2.call(slots, {
          index: i,
          value: item.value
        })) ?? item.value]);
      })]), createVNode("path", {
        "ref": path,
        "d": genPath2(props.fill),
        "fill": props.fill ? `url(#${id.value})` : "none",
        "stroke": props.fill ? "none" : `url(#${id.value})`
      }, null), props.fill && createVNode("path", {
        "d": genPath2(false),
        "fill": "none",
        "stroke": props.color ?? ((_a = props.gradient) == null ? void 0 : _a[0])
      }, null)]);
    });
  }
});

// node_modules/vuetify/lib/labs/VSparkline/VSparkline.mjs
var makeVSparklineProps = propsFactory({
  type: {
    type: String,
    default: "trend"
  },
  ...makeVBarlineProps(),
  ...makeVTrendlineProps()
}, "VSparkline");
var VSparkline = genericComponent()({
  name: "VSparkline",
  props: makeVSparklineProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    const hasLabels = computed(() => {
      return Boolean(props.showLabels || props.labels.length > 0 || !!(slots == null ? void 0 : slots.label));
    });
    const totalHeight = computed(() => {
      let height = parseInt(props.height, 10);
      if (hasLabels.value)
        height += parseInt(props.labelSize, 10) * 1.5;
      return height;
    });
    useRender(() => {
      const Tag = props.type === "trend" ? VTrendline : VBarline;
      const lineProps = props.type === "trend" ? VTrendline.filterProps(props) : VBarline.filterProps(props);
      return createVNode(Tag, mergeProps({
        "key": props.type,
        "class": textColorClasses.value,
        "style": textColorStyles.value,
        "viewBox": `0 0 ${props.width} ${parseInt(totalHeight.value, 10)}`
      }, lineProps), slots);
    });
  }
});

// node_modules/vuetify/lib/labs/VSpeedDial/VSpeedDial.mjs
import "C:/Users/rakov/OneDrive/Рабочий стол/test/test/node_modules/vuetify/lib/labs/VSpeedDial/VSpeedDial.css";
var makeVSpeedDialProps = propsFactory({
  ...makeComponentProps(),
  ...makeVMenuProps({
    offset: 8,
    minWidth: 0,
    location: "top center"
  }),
  ...makeTransitionProps({
    transition: "fade-transition"
  })
}, "VSpeedDial");
var VSpeedDial = genericComponent()({
  name: "VSpeedDial",
  props: makeVSpeedDialProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => {
      const menuProps = VMenu.filterProps(props);
      return createVNode(VMenu, mergeProps(menuProps, {
        "class": props.class,
        "style": props.style,
        "contentClass": "v-speed-dial__content"
      }), {
        default: () => [createVNode(VDefaultsProvider, {
          "defaults": {
            VBtn: {
              size: "small"
            }
          }
        }, {
          default: () => [createVNode(MaybeTransition, {
            "appear": true,
            "group": true,
            "transition": props.transition
          }, {
            default: () => {
              var _a;
              return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
            }
          })]
        })]
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VTreeview/VTreeviewGroup.mjs
var makeVTreeviewGroupProps = propsFactory({
  ...omit(makeVListGroupProps({
    collapseIcon: "$treeviewCollapse",
    expandIcon: "$treeviewExpand"
  }), ["subgroup"])
}, "VTreeviewGroup");
var VTreeviewGroup = genericComponent()({
  name: "VTreeviewGroup",
  props: makeVTreeviewGroupProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const vListGroupRef = ref();
    const toggleIcon = computed(() => {
      var _a;
      return ((_a = vListGroupRef.value) == null ? void 0 : _a.isOpen) ? props.collapseIcon : props.expandIcon;
    });
    const activatorDefaults = computed(() => {
      var _a;
      return {
        VTreeviewItem: {
          prependIcon: void 0,
          appendIcon: void 0,
          active: (_a = vListGroupRef.value) == null ? void 0 : _a.isOpen,
          toggleIcon: toggleIcon.value
        }
      };
    });
    useRender(() => {
      const listGroupProps = VListGroup.filterProps(props);
      return createVNode(VListGroup, mergeProps(listGroupProps, {
        "ref": vListGroupRef,
        "class": ["v-treeview-group", props.class],
        "subgroup": true
      }), {
        ...slots,
        activator: slots.activator ? (slotProps) => createVNode(Fragment, null, [createVNode(VDefaultsProvider, {
          "defaults": activatorDefaults.value
        }, {
          default: () => {
            var _a;
            return [(_a = slots.activator) == null ? void 0 : _a.call(slots, slotProps)];
          }
        })]) : void 0
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VTreeview/VTreeviewItem.mjs
import "C:/Users/rakov/OneDrive/Рабочий стол/test/test/node_modules/vuetify/lib/labs/VTreeview/VTreeviewItem.css";

// node_modules/vuetify/lib/labs/VTreeview/shared.mjs
var VTreeviewSymbol = Symbol.for("vuetify:v-treeview");

// node_modules/vuetify/lib/labs/VTreeview/VTreeviewItem.mjs
var makeVTreeviewItemProps = propsFactory({
  loading: Boolean,
  toggleIcon: IconValue,
  ...makeVListItemProps({
    slim: true
  })
}, "VTreeviewItem");
var VTreeviewItem = genericComponent()({
  name: "VTreeviewItem",
  props: makeVTreeviewItemProps(),
  setup(props, _ref) {
    let {
      attrs,
      slots,
      emit
    } = _ref;
    const link = useLink(props, attrs);
    const id = computed(() => props.value === void 0 ? link.href.value : props.value);
    const vListItemRef = ref();
    const isClickable = computed(() => {
      var _a;
      return !props.disabled && props.link !== false && (props.link || link.isClickable.value || props.value != null && !!((_a = vListItemRef.value) == null ? void 0 : _a.list));
    });
    function onClick(e) {
      var _a, _b, _c;
      if (!((_a = vListItemRef.value) == null ? void 0 : _a.isGroupActivator) || !isClickable.value)
        return;
      props.value != null && ((_c = vListItemRef.value) == null ? void 0 : _c.select(!((_b = vListItemRef.value) == null ? void 0 : _b.isSelected), e));
    }
    function onKeyDown(e) {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        onClick(e);
      }
    }
    const visibleIds = inject(VTreeviewSymbol, {
      visibleIds: ref()
    }).visibleIds;
    useRender(() => {
      const listItemProps = VListItem.filterProps(props);
      const hasPrepend = slots.prepend || props.toggleIcon;
      return createVNode(VListItem, mergeProps({
        "ref": vListItemRef
      }, listItemProps, {
        "class": ["v-treeview-item", {
          "v-treeview-item--filtered": visibleIds.value && !visibleIds.value.has(id.value)
        }, props.class],
        "onClick": onClick,
        "onKeydown": isClickable.value && onKeyDown
      }), {
        ...slots,
        prepend: hasPrepend ? (slotProps) => {
          var _a;
          return createVNode(Fragment, null, [props.toggleIcon && createVNode(VListItemAction, {
            "start": false
          }, {
            default: () => [createVNode(VBtn, {
              "density": "compact",
              "icon": props.toggleIcon,
              "loading": props.loading,
              "variant": "text"
            }, {
              loader() {
                return createVNode(VProgressCircular, {
                  "indeterminate": "disable-shrink",
                  "size": "20",
                  "width": "2"
                }, null);
              }
            })]
          }), (_a = slots.prepend) == null ? void 0 : _a.call(slots, slotProps)]);
        } : void 0
      });
    });
    return {};
  }
});

// node_modules/vuetify/lib/labs/VTreeview/VTreeviewChildren.mjs
var makeVTreeviewChildrenProps = propsFactory({
  loadChildren: Function,
  loadingIcon: {
    type: String,
    default: "$loading"
  },
  items: Array,
  selectable: Boolean
}, "VTreeviewChildren");
var VTreeviewChildren = genericComponent()({
  name: "VTreeviewChildren",
  props: makeVTreeviewChildrenProps(),
  setup(props, _ref) {
    let {
      emit,
      slots
    } = _ref;
    const isLoading = shallowRef(false);
    const hasLoaded = shallowRef(false);
    function checkChildren(item) {
      return new Promise((resolve) => {
        var _a;
        if (!((_a = props.items) == null ? void 0 : _a.length) || !props.loadChildren || hasLoaded.value)
          return resolve();
        isLoading.value = true;
        props.loadChildren(item).then(resolve);
      }).then(() => {
        hasLoaded.value = true;
      }).finally(() => {
        isLoading.value = false;
      });
    }
    function onClick(e, item) {
      e.stopPropagation();
      checkChildren(item);
    }
    return () => {
      var _a, _b;
      return ((_a = slots.default) == null ? void 0 : _a.call(slots)) ?? ((_b = props.items) == null ? void 0 : _b.map((_ref2) => {
        var _a2;
        let {
          children,
          props: itemProps,
          raw: item
        } = _ref2;
        const slotsWithItem = {
          prepend: slots.prepend ? (slotProps) => {
            var _a3;
            return (_a3 = slots.prepend) == null ? void 0 : _a3.call(slots, {
              ...slotProps,
              item
            });
          } : props.selectable ? (_ref3) => {
            let {
              isSelected,
              isIndeterminate
            } = _ref3;
            return createVNode(VCheckboxBtn, {
              "key": item.value,
              "tabindex": "-1",
              "modelValue": isSelected,
              "loading": isLoading.value,
              "indeterminate": isIndeterminate,
              "onClick": (e) => onClick(e, item)
            }, null);
          } : void 0,
          append: slots.append ? (slotProps) => {
            var _a3;
            return (_a3 = slots.append) == null ? void 0 : _a3.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          title: slots.title ? (slotProps) => {
            var _a3;
            return (_a3 = slots.title) == null ? void 0 : _a3.call(slots, {
              ...slotProps,
              item
            });
          } : void 0
        };
        const treeviewGroupProps = VTreeviewGroup.filterProps(itemProps);
        const treeviewChildrenProps = VTreeviewChildren.filterProps(props);
        return children ? createVNode(VTreeviewGroup, mergeProps({
          "value": itemProps == null ? void 0 : itemProps.value
        }, treeviewGroupProps), {
          activator: (_ref4) => {
            let {
              props: activatorProps
            } = _ref4;
            return createVNode(VTreeviewItem, mergeProps(itemProps, activatorProps, {
              "loading": isLoading.value,
              "onClick": (e) => onClick(e, item)
            }), slotsWithItem);
          },
          default: () => createVNode(VTreeviewChildren, mergeProps(treeviewChildrenProps, {
            "items": children
          }), slots)
        }) : ((_a2 = slots.item) == null ? void 0 : _a2.call(slots, {
          props: itemProps
        })) ?? createVNode(VTreeviewItem, itemProps, slotsWithItem);
      }));
    };
  }
});

// node_modules/vuetify/lib/labs/VTreeview/VTreeview.mjs
function flatten(items) {
  let flat = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  for (const item of items) {
    flat.push(item);
    if (item.children)
      flatten(item.children, flat);
  }
  return flat;
}
var makeVTreeviewProps = propsFactory({
  openAll: Boolean,
  search: String,
  ...makeFilterProps({
    filterKeys: ["title"]
  }),
  ...makeVTreeviewChildrenProps(),
  ...omit(makeVListProps({
    collapseIcon: "$treeviewCollapse",
    expandIcon: "$treeviewExpand",
    selectStrategy: "independent",
    openStrategy: "multiple",
    slim: true
  }), ["nav"])
}, "VTreeview");
var VTreeview = genericComponent()({
  name: "VTreeview",
  props: makeVTreeviewProps(),
  emits: {
    "update:opened": (val) => true,
    "update:activated": (val) => true,
    "update:selected": (val) => true,
    "click:open": (value) => true,
    "click:select": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      items
    } = useListItems(props);
    const activeColor = toRef(props, "activeColor");
    const baseColor = toRef(props, "baseColor");
    const color = toRef(props, "color");
    const opened = useProxiedModel(props, "opened");
    const activated = useProxiedModel(props, "activated");
    const selected = useProxiedModel(props, "selected");
    const vListRef = ref();
    const flatItems = computed(() => flatten(items.value));
    const search = toRef(props, "search");
    const {
      filteredItems
    } = useFilter(props, flatItems, search);
    const visibleIds = computed(() => {
      if (!search.value) {
        return null;
      }
      return new Set(filteredItems.value.flatMap((item) => {
        return [...getPath(item.props.value), ...getChildren(item.props.value)];
      }));
    });
    function getPath(id) {
      var _a;
      const path = [];
      let parent = id;
      while (parent != null) {
        path.unshift(parent);
        parent = (_a = vListRef.value) == null ? void 0 : _a.parents.get(parent);
      }
      return path;
    }
    function getChildren(id) {
      var _a, _b;
      const arr = [];
      const queue = (((_a = vListRef.value) == null ? void 0 : _a.children.get(id)) ?? []).slice();
      while (queue.length) {
        const child = queue.shift();
        if (!child)
          continue;
        arr.push(child);
        queue.push(...(((_b = vListRef.value) == null ? void 0 : _b.children.get(child)) ?? []).slice());
      }
      return arr;
    }
    watch(() => props.openAll, (val) => {
      opened.value = val ? openAll(items.value) : [];
    }, {
      immediate: true
    });
    function openAll(item) {
      let ids = [];
      for (const i of item) {
        if (!i.children)
          continue;
        ids.push(i.value);
        if (i.children) {
          ids = ids.concat(openAll(i.children));
        }
      }
      return ids;
    }
    provide(VTreeviewSymbol, {
      visibleIds
    });
    provideDefaults({
      VTreeviewGroup: {
        activeColor,
        baseColor,
        color,
        collapseIcon: toRef(props, "collapseIcon"),
        expandIcon: toRef(props, "expandIcon")
      },
      VTreeviewItem: {
        activeClass: toRef(props, "activeClass"),
        activeColor,
        baseColor,
        color,
        density: toRef(props, "density"),
        disabled: toRef(props, "disabled"),
        lines: toRef(props, "lines"),
        variant: toRef(props, "variant")
      }
    });
    useRender(() => {
      const listProps = VList.filterProps(props);
      const treeviewChildrenProps = VTreeviewChildren.filterProps(props);
      return createVNode(VList, mergeProps({
        "ref": vListRef
      }, listProps, {
        "class": ["v-treeview", props.class],
        "style": props.style,
        "opened": opened.value,
        "onUpdate:opened": ($event) => opened.value = $event,
        "activated": activated.value,
        "onUpdate:activated": ($event) => activated.value = $event,
        "selected": selected.value,
        "onUpdate:selected": ($event) => selected.value = $event
      }), {
        default: () => [createVNode(VTreeviewChildren, mergeProps(treeviewChildrenProps, {
          "items": items.value
        }), slots)]
      });
    });
    return {
      open
    };
  }
});
export {
  VCalendar,
  VCalendarDay,
  VCalendarHeader,
  VCalendarInterval,
  VCalendarIntervalEvent,
  VCalendarMonthDay,
  VConfirmEdit,
  VEmptyState,
  VFab,
  VPicker,
  VPickerTitle,
  VSparkline,
  VSpeedDial,
  VTreeview,
  VTreeviewGroup,
  VTreeviewItem
};
//# sourceMappingURL=vuetify_labs_components.js.map
